# 你不知道的JavaScript（上）

## 1. 作用域

### 1.1 编译原理

`Javascript`与传统的编译语言不同，他`不是`提前编译的，编译结果也不能在分布式系统中进行移植。

传统编译语言的流程中，程序中的一段源代码在执行前会经历三个步骤，统称为“==编译==”

* **分词/词法分析（Tokenizing/Lexing）**

  将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（token）

* **解析/语法分析（Parsing）**

  将词法单元流（数组）转换成一个有元素逐级嵌套所组成的代表了程序语法的树。这个树被称为“`抽象语法树`”（Abstract Syntax Tree，AST）

* **代码生成**

  将`AST`转换为可执行代码的过程被称为代码生成

相比于编译过程只有三个步骤的语言的编译器，JavaScript引擎要复杂得多。

![image-20210117141244928](你不知道的JavaScript.assets\image-20210117141244928.png)

### 1.2 理解作用域

#### 1.2.1 演员表

* **引擎**

  从头到尾负责整个JavaScript程序的编译及执行过程

* **编译器**

  负责语法分析及代码生成等

* **作用域**

  负责收集并维护由所有生命的标志符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标志符的访问权限

#### 1.2.2 对话

var a = 2; 这段程序有两个完全不同的声明，一个由`编译器`在==编译时==处理，另一个则由`引擎`在==运行时==处理。

编译器会进行如下处理：

1. 遇到 var a，编译器会询问作用于是否已经有一个该名称的变量存在于同一个走用于的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a。
2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 `a = 2` 这个复制操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫做a的变量。如果是，引擎就会使用这个变量，如果否，引擎会继续查找该变量。如果引擎最终找到了a变量，就会将2赋值给它，否则引擎就会抛出一个异常。

> 总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如 果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对 它赋值。

#### 1.2.3 编译器有话说

`LHS` 和`RHS` 查询：当变量出现在赋值操作的做测试进行`LHS`查询，出现在右侧时进行 `RHS` 查询 

> 讲得更准确一点，RHS 查询与简单地查找某个变量的值别无二致，而 LHS 查询则是试图 找到变量的容器本身，从而可以对其赋值。从这个角度说，RHS 并不是真正意义上的“赋 值操作的右侧”，更准确地说是“非左侧”。

例如：

console.log(a) ：其中对a的引用是`RHS`引用。因为这里a并没有赋予任何值，相应的，需要查找并取得a的值，这样才能将值传递给console.log()。

a = 2 ：这里对a的引用则是`LHS`引用。因为实际上我们并不关心当前的值是什么，只是想要为 = 2 这个赋值操作找到一个目标

> LHS 和 RHS 的含义是“赋值操作的左侧或右侧”并不一定意味着就是“= 赋值操作符的左侧或右侧”。赋值操作还有其他几种形式，因此在概念上最 好将其理解为“赋值操作的目标是谁（LHS）”以及“谁是赋值操作的源头 （RHS）”。

![image-20210117151027936](你不知道的JavaScript.assets\image-20210117151027936.png)

![image-20210117151131289](你不知道的JavaScript.assets\image-20210117151131289.png)

### 1.3 作用域嵌套

当一个块或函数嵌套在另一个块或者函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。

### 1.4 异常

`LHS` 和 `RHS`在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行为是不一样的。

对一个==未声明==的变量进行`RHS`查询时`引擎`会抛出ReferenceError。进行`LHS`查询时，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非“严格模式”下。

> ES5 中引入了“严格模式”。同正常模式，或者说宽松 / 懒惰模式相比，严格模式在行为上 有很多不同。其中一个不同的行为是严格模式禁止自动或隐式地创建全局变量。因此，在 严格模式中 LHS 查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 RHS 查询 失败时类似的 ReferenceError 异常。

## 2 词法作用域

作用域共有两种主要的工作模型：

* 词法作用域：大多数编程语言采用
* 动态作用域：一些编程语言使用（Bash脚本，Perl中的一些模式）

JavaScript采用`词法作用域`

### 2.1 词法阶段

大部分标准语言编译器的第一个工作阶段叫做词法化（也叫单词化），即此法阶段。

`词法作用域`就是定义在词法阶段的作用域。`词法作用域`是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。

![image-20210117171628435](你不知道的JavaScript.assets\image-20210117171628435.png)

==作用域查找会在找到第一个匹配的标志符停止==。在多层的嵌套作用域中可以定义同名的标志符，这叫做“`遮蔽效应`”（内部的标志符“遮蔽”了外部的标志符）。抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标志符为止。

> 全局变量会自动成为全局对象（比如浏览器中的 window 对象）的属性，因此 可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引 用来对其进行访问。 
>
> ​	window.a 
>
> 通过这种技术可以访问那些被同名变量所遮蔽的全局变量。但非全局的变量 如果被遮蔽了，无论如何都无法被访问到。

无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处 的位置决定。

### 2.2 欺骗词法

#### 2.2.1 eval

