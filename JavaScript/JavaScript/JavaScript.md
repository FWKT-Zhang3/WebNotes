# JavaScript Notes

###### -- Max Zhang

## 了解 JS:

- 在一个页面中
  - html&#9;&#9;表示结构
  - css&#9;&#9;表示样式
  - JS&#9;&#9;&#9;表示行为

- JS三大核心

  - ECMAScript

    > JS的标准，语法

  - BOM(Browser Object Model)

    > 一整套操作浏览器的属性和方法

  - DOM(Documentv Object Model)

    > 一整套操作文档流的属性和方法
    >
    > 文档对象模型 (DOM) 是HTML和XML文档的编程接口。它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容。
    > DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。简言之，它会将web页面和脚本或程序语言连接起来。
    >
    > ![DOM tree](JavaScript.assets/9064730-3b5a9a5545a02fd2.webp)

## 2. JS的书写

分成三种方式：

1. 行内式(强烈不推荐)
    - a标签
      - 因为a标签本身就有行为出现
      - 当点击的时候需要区分是跳转连接还是执行JS代码
      - 在href属性里写 javascript: JS代码
      - [点我试试](https://www.baidu.com)
      - 再点我试试
      - [a标签中的JS](javascript: alert('Hello World!'))
    - 非a标签
      - 因为没有自己的行为，所以要给他加个行为(事件)
      - 这个div加了onclick属性
2. 内嵌式(不推荐)
    - 在页面内书写一个script标签
    - 把JS代码书写在标签的内部
    - 不需要任何行为，只要打开页面就会执行
    - 一个页面内可以书写无限个script标签，会按照从上到下的顺序依次执行
    - 理论上script标签可以放在页面的任何位置，推荐放到head或body的末尾
3. 外链式(推荐)
    - 把JS代码写在一个.js后缀的文件里面
    - 在页面上通过script标签的src属性引入页面
    - 当一个script标签被当做外链式使用的时候，写在标签对里面的内容没有意义

## 3. JS的注释

```javascript
// 单行注释
/* 多行注释 */
```

## 4. JS的输出语法

```javascript
1. alert() -> 浏览器弹出窗
2. console.log() -> 浏览器控制台
3. document.write() -> 输出到页面内（可以解析标签）
```

## 5. 变量

```javascript
var 变量名 = 变量值
// 不使用var关键字也可以定义变量，但是强烈不推荐
```

命名规则：

1. 一个变量只能由数字，字母，美元符，下划线组成
2. 一个变量不能由数字开头
3. JS中严格区分大小写
4. 不能使用关键字保留字

命名规范：

1. 不要用中文
2. 变量语义化
3. 驼峰命名法

## 6. 数据类型

1. 基本数据类型（简单数据类型）
   * Number 数值
     * 一切十进制表示的数字
     * 一切浮点数
     * 其他进制的数字（16进制，0x开头；8进制，0开头；二进制，0b开头）
     * 科学技术法：2e5 => 2 $\times$ 10^5^
     * NaN: Not a Number
     * （在控制台输出其他进制的数字的时候，会自动转换成十进制）
     
   * String 字符串

     * 在JS里面一切使用引号（双引号，单引号，反引号）包裹的内容都是字符串
     * 表示一段文本内容，是一个字符一个字符连接起来的内容
     * 在字符串里面只写数字的时候，也不是数值类型
     * 空格直接占位

     ```javascript
     'Hello'
     "Hello"
     `Hello` (反引号是ES6新引进)
     ```

   * Boolean 布尔

     * true 表示真，在计算机储存的时候为1
     * false 表示假，在计算机储存的时候为0

   * Undefined 未定义

     * 本该有一个值，但是没有

   * Null 空

     * 这里有一个空值

   ```javascript
   检测数据类型：
   关键字 typeof
       1. typeof 变量
   	返回值：以字符串的形式给你的变量数据类型
       var n1 = 100
       var res1 = typeof n1
       
       2. typeof（变量）
       var res2 = typeof(n1)
       
       // 第一种只能检测紧跟着的一个变量
       // 第二种先运算小括号里面的结果，然后使用typeof去检测结果的数据类型
       // 当两个及以上typeof连用的时候，一定得到string
       // 只能准确地检测基本数据类型
       	-> 数值：number
       	-> 字符串：string
       	-> 布尔值：boolean
       	-> undefined：undefined
   	    -> null：object
   ```

   数据类型转换转数值

   * 转数值

     1. Number()

        * 语法：Number(要转换的数据)
        * 返回值：转换好的数据
        * 特点：
          * 会把要转化的内容当做一个整体来看待
          * 能转换成数字结果，就是数字结果
          * 不能转换成数字结果，就是NaN
          * true：1，false：0

     2. parseInt()

        * 语法：parseInt(要转换的数据)
        * 返回值：转换好的数据
        * 特点：
          * 把要转换的任何内容一位一位的看
          * 如果第一位不能转换成数字，直接NaN
          * 如果第一位可以，第一位保留，看第二位
          * 以此类推，直到一个不能转换成合法数字的位置为止不认识
          * 不认识小数点

        ```javascript
        var n1 = "123abc"
        var res1 = Number(n1) // NaN
        var res2 = parseInt(n1) // 123
        
        var n2 =  true
        var res3 = Number(n2) // 1
        var res4 = parseInt(n2) // NaN
        
        var n3 = "123.456"
        var res5 = Number(n3) // 123.456
        var res6 = parseInt(n3) // 123
        ```

     3. parseFloat()

        * 语法：parseFloat(要转换的数据)
        * 返回值：转换好的数据
        * 特点：
          * 和parseInt的解析规则一模一样，只多认识一个小数点

     4. 取正负值

        * 语法：+变量 或者 -变量
        * 返回值：转换好的数据
        * 特点：和Number的解析规则相同

        ```javascript
        var s = "100"
        var res1 = +s // 100
        var res2 = -s // -100
        ```

     5. 非加法的数学运算

        * 语法：

          a * 1

          a - 0

          a / 1

        * 特点：和Number的解析规则相同

   * 转字符串

     1. String()
        * 语法：String(要转换的数据)
        * 返回值：转换好的数据
        * 特点：任何数据类型都能转换
     2. toString()
        * 语法：要转换的数据.toString()
        * 返回值：转换好的数据
        * 特点：undefined和null不能转换
     3. 加法运算
        * +号有两个意义：
          * 字符串拼接：符号任意一边是字符串的时候
          * 数学运算：两边都是数字或者布尔的时候

   * 转布尔

     1. Boolean()
        * 语法：Boolean(要转换的数据)
        * 返回值：转换好的数据
        * 特点：只有五个内容会转成false：
          * 0
          * 空字符串
          * NaN
          * undefined
          * null
     2. 双取反（!!）

2. 复杂数据类型（地址数据类型/引用数据类型）
   * Object
   * Function



## 7. 运算符

**数学运算符**：

1. +
   * 字符串拼接
   * 数学运算
2. -
3. *
4. /
5. %：取余
6. **：取幂

**赋值运算符**：

=，+=，*=，/=，%=，-=

**比较运算符**：

\>, <, >=, <=, \==, \=\==, !=, !==

> 和其他语言有些不同，在 JavaScript 中除了用`==`操作符来判断是否相等外，还有一个`===`操作符，它们的区别是：`==`操作符会先将两边的值进行强制类型转换再比较是否相等，而`===`操作符不会进行类型转换。`==`操作符只要求比较两个值是否相等，而`===`操作符不仅要求值相等，而且要求类型相同。`!=`和`!==`的区别也是类似的，`!=`号会做强制类型转换，而`!==`不会。

```javascript
// 注意，这里有一个特殊值NaN，即 Not a Number，表示非数字，它和任何数做相等比较，包括它自己，都会返回false。所以判断NaN最好用isNaN()函数。

// false
NaN == NaN
// false
NaN === NaN


// 还有两个特殊值undefined和null，使用时需要注意

// true
null == undefined
// false
null === undefined


// != 和 !== 的情况与==，===的情况类似
```

**逻辑运算符**：

1. && 逻辑与
2. || 逻辑或
3. ！逻辑非

**自增自减运算符**：

一元运算符一种

自增：i++，++i

自减：i--，--i

当出现多个自增自减时，从左到右计算



## 8. 条件分支语句

1. if 语句

   * if（条件）{ 要执行的代码 } else if （条件）{ 要执行的代码 } else { 要执行的代码 }

2. switch

   `case的值` 和 `变量的值`必须是`===`

   只能是`精确的值`，不能是范围

   执行`break`才会跳出，执行完一个case如果没有break跳出，则会直接执行下一条，**无论条件是否满足**。

   ```javascript
   switch (要判断的变量) {
           case 情况1：
           	代码
           	break
           case 情况2：
           	代码
           	break
           default：// 可以不写
           	代码
   }
   ```

## 9.循环结构语句

1. 初始值：作为循环的开始
2. 条件判断：决定要不要继续循环
3. 要重复执行的代码
4. 改变初始值：为了让循环有结束

**while**：

```javascript
while (条件) {
    代码
    改变初始值
}
```

**dowhile**：

```javascript
do {
    代码
} while (条件)
```

至少会执行一次

**for**：

```javascript
for (var i = 0; i < 10; i++) {
    代码
}
```

`break`：跳出

`continue`：结束本次，继续下次

`JS标记语法`：

```javascript
Outer: // 名字随便起
for (var i = 1; i <= 5; i++) {
    for (var j = 1; j <= 3; j++) {
        if ( i === 3 && j === 2) {
            console.log("k看到半条虫子")
            break Outer
        }
        console.log("吃的第 " + i + " 个包子的第 " + j + " 口")
    }
}
```

```javascript
// 判断是不是质数
// 可以从 2 开始
// 当大于数字的一半时，不能整除
// 当一个数字能开出平方根，到这个平方根就可以结束了
```

## 10. 函数

1. 声明式函数

   语法：function 函数名() { }

2. 赋值式函数

   语法：var 函数名 = function () { }

`函数名`和`函数名()`是不一样的：

* `函数名`是一个变量，表示这个函数
* `函数名()`是执行这个函数

函数调用上的区别：

* 两种声明方式，调用方式是一样的
* 区别：调用的时机不一样
  * 声明式函数：可以在声明之前调用，也可以在声明之后调用
  * 赋值式函数：只能在声明之后调用

函数参数的个数关系

* 一样多

  按照从左到右的顺序一一对应

* 实参多

  前面的按照顺序一一对应，多出来的实参，在函数内部没有形参接收

  不能直接使用

* 形参多

  前面的按照顺序一一对应，多出来的形参因为没有实参赋值，所以使用的时候就是`undefined`

**arguements**（实参数组）:

* 在函数内部天生自带的变量
* 表示所有实参的集合
* arguement 的属性
  * length：实参个数，可读写
  * 排列：索引排列，从零开始
  * arguement[index] 可读取相应位置数据，可读写

```javascript
function func() {
    var a = arguements[0]
    console.log(a)
}
```

**函数和元素结合**：

* 函数还可以当做一个页面元素的事件处理函数
* 当页面上某个元素处罚行为的时候，执行某个函数
* 语法：元素.行为 = 函数

页面元素的简单操作：

* 在一个页面里面，**元素的 id 名，可以直接当做一个变量来使用**
* 这个变量就代表着这个元素

两种方式：

* 直接书写匿名函数

  元素.行为 = 函数

* 给事件赋值具名函数

  元素.行为 = 函数名（注意：没有括号）

  ```javascript
  function fn() {
      console.log(123)
  }
  
  box.onclick = fn // 没有括号
  
  // fn 这个变量名代表了一个函数
  // fn() 表示执行这个函数
  ```

> JS的安全数字范围：$(-2^{53} + 1)$ ~ $(2^{53} - 1)$
>
> 
>
> 超过这个范围，可以使用BigInteger（2020年新，仍有问题，尚未普及。例如Math.floor(10n)会报错：Cannot convert a BigInt value to a number at Math.floor）
>
> 直接在数字后面加`n`或者用BigInt()转换（只保留整数部分）



## 11. 预解析

* 不是关于怎么写代码
* 关于了解代码的执行机制，和不要怎么写代码
* 预：预先，在所有代码执行之前
* 解析：解释，对代码进行通读并解释（只是把整体代码当做一个文档）

解释的部分：

1. `var`关键字：会把`var`关键字定义的变量在代码执行之前声明

   ```javascript
   /* 
   	当代码在浏览器执行的时候，
   	在所有代码开始执行之前，先把声明做好（var num）
   */
   var num = 100 // 当代码执行到这一行才会赋值
   
   /*
   	下面这段代码的执行顺序其实是：
   	var a
   	console.log(a)
   	a = 100
   	console.log(a)
   */
   console.log(a) // 这里会打印undefined
   var a = 100
   console.log(a)
   ```

2. 声明式函数：会把这个函数名在所有代码执行前声明，并且赋值为一个函数

   ```javascript
   // 在所有代码执行前，告诉浏览器，fn这个名字可以使用，并且fn代表的是一个函数
   // 所以在函数声明之前也可以调用函数
   function fn() 
       console.log("一个函数")
   }
   ```

> 注意：赋值式函数 => var fn = function() {...}
>
> 按照var的规则进行解析

如果有`变量名`和`函数名`重名，在预解析阶段以函数为准

```javascript
/*
	预解析：
		1. var fn // 声明fn变量
		2. function fn() {...} // 声明fn变量，并且赋值为一个函数
		3. 预解析结束的时候，记录的fn变量是一个函数
		
	代码开始执行
		1. fn()
		2. fn = 100	// 从这里开始，fn就不再是一个函数了，只是一个数值100，所以后续的函数调用会报错
				   // TypeError: fn is not a function
		3. fn()
		4. fn()
*/
fn()
var fn = 100
fn()
function fn() {
    console.log("This is a function")
}
fn()
```

`if`条件无论成立与否，里面的代码会进行预解析

## 12. 作用域

* 教你怎么写代码
* 变量（变量名，函数名）生效的范围

两种：

1. 全局作用域

   打开一个页面就是一个全局作用域

   全局作用域，叫window

2. 私有作用域（局部作用域）

   只有函数生成私有作用域

   每一个函数就是一个私有作用域

作用域的上下级关系：

* 函数写在哪个作用域下，就是谁的子级作用域

作用域的上下级关系：

* 为了确定变量的使用范围

* ==三个机制==

  1. 变量定义机制

     * 有 var 关键字
     * 声明式函数

     一个变量定义在哪一个作用于里面，就只能在该作用域或其下级作用域里面使用，上级作用域不能使用

  2. 变量使用机制

     拿某一个变量的值来使用

     当需要使用一个变量（函数）会首先在自己作用域内查找，如果有，直接使用；如果没有，去上级作用域查找；如果直到全局作用域都没有查到，**报错**

  3. 变量赋值机制

     一定要有赋值符号

     当给一个变量（函数名）赋值的时候，首先在自己的作用域里面查找，如果有，直接赋值；如果没有，去上级作用域查找；如果直到全局作用域都没有查到，**把这个变量定义为全局变量，再进行赋值**

  > 赋值符号是从右向左赋值

```javascript
function fn() {
    var num = 100
    
    function fun() {
        // 变量的使用和赋值
        // 预解析的时候，fun函数里面会预解析一个 num 变量（属于fun的私有作用域）
        // 使用num的值，赋值给num
        // 就是把undefined 赋值给 num
        var num = num
        console.log(num) // 这里会打印undefined
    }
    
    fun()
}
```

==作用域里面的预解析==

预解析分成几个阶段：

* 全局预解析
  * 页面打开的时候就进行了
  * 只解释属于全局的内容
* 私有作用域解析
  * 当函数执行的时候，进行预解析
  * 函数内部的预解析，只属于函数内部

> 问题：函数执行的时候，会进行`形参赋值`和`预解析`，一旦函数的形参和定义的私有变量重名，先预解析还是先形参赋值？

```javascript
function fn(b) {
    function b() {
        console.log("b")
    }
    b() // 报错？不报错？
}

fn(200)
// 如果预解析在前，形参赋值在后
// 这个fn函数执行的时候，先把 b 解析成为一个函数
// 然后再给b赋值为200，那么就会报错了

// 如果预解析在后，形参赋值在前
// 这个fn函数执行的时候，先把b赋值为两百
// 然后预解析的时候，把b赋值为函数，就不会报错
```

> 这里不会报错，在函数执行的时候，先进行形参赋值，再进行预解析

## 13 对象数据类型

* JS数据类型的一种
* 一个复杂数据类型
* 函数：一个盒子，承载一段代码
* 对象：一个盒子，承载一堆数据

对象的创建方式：

1. 字面量创建：var o = {}
2. 内置构造函数创建：var o = new Object()

> 区别：
>
> 1. 字面量创建可以在创建的时候就直接向对象里面添加一些数据
>
>    key：value键值对，用逗号( , )隔开，key即对象的属性
>
> 2. 内置构造函数不好直接添加成员，后期通过对象的操作语法来进行增删改查

```javascript
var o = {
    num : 100, // 对象的属性
    name : "Jack",
    fn : function () { console.log("o的fn函数") } // 对象的方法
    // 每个成员的名称都是字符串
}
```

**对象的操作语法：**

> 语法有两种：
>
> 1. 点语法
> 2. 数组关联语法

* 增：
  * 对象名.成员名 = 值
  * 对象名["成员名"] = 值
* 删
  * delete 对象名.成员名
  * delete 对象名["成员名"]
* 改
  * 对象名.成员名 = 值
  * 对象名["成员名"] = 值
* 查
  * 对象名.成员名
  * 对象名["成员名"]

> 注意：因为对象数据类型是一个复杂数据类型，在控制台打印的时候，会出现两种情况：
>
> * 不展开对象数据类型的时候，是当前的样子
> * 展开对象数据类型后，显示最终的样子
>
> 解决方法：
>
> * 单独打印属性
> * 使用console.table()

两种操作语法的区别：

* 点语法：
  * 不能使用变量
  * 不能拼接字符串
* 数组关联语法
  * 可以使用变量
  * 可以拼接字符串



**循环遍历对象：**

for in 循环

for (var 变量 in 对象) {...} ：这里 `变量` 指的是属性名



**判断一个成员是不是在这个对象里：**

使用`in`语法：成员名 in 对象名

```javascript
var o = {
	name : "Max",
    age : 25
}
console.log(name in o) // 这里是false
console.log("name" in o) // true
```